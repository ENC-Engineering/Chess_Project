//pass this boolean to move every-time to edit
//also push into generate moves, move, checkmate, and checkmoves
bool en_passant-possible=false;
int p_cor=0;

//add to move and checkmoves
//checkmoves part
if (game.board[y_cor][x_cor]->type.compare("pawn")){
	if (en_passant_possible){
		if (x_cans.top()==p_cor && (y_cans.top==(5) && game.board[y_cor][x_cor]->isBlack)){
			if (game.board[5][p_cor]==0){
				Piece* temp=game.board[y_cor][x_cor];
				Piece* temp2=game.board[4][p_cor];
				game.board[5][p_cor]=game.board[y_cor][x_cor];
				game.board[4][p_cor]=0;
				in_check=check(game, player_color);
				game.board[y_cor][x_cor]=temp;
				game.board[3][p_cor]=temp2;
				x_cans.pop();
				y_cans.pop();
			}
		}
		else if (x_cans.top()==p_cor && (y_cans.top==(2) && game.board[y_cor][x_cor]->!isBlack)){
			if (game.board[2][p_cor]==0){
				Piece* temp=game.board[y_cor][x_cor];
				Piece* temp2=game.board[3][p_cor];
				game.board[2][p_cor]=game.board[y_cor][x_cor];
				game.board[3][p_cor]=0;
				in_check=check(game, player_color);
				game.board[y_cor][x_cor]=temp;
				game.board[3][p_cor]=temp2;
				x_cans.pop();
				y_cans.pop();
			}
		}
	}
}
//moves part after they specify where they want to move, put in the actual loop after they know that x_move and y_move is the place they want to go to
if (game.board[y_cor][x_cor]->type.compare("pawn")==0){
	if (en_passant_possible){
		if (x_move==p_cor && y_move==5 && game.board[y_cor][x_cor]->isBlack){
			if (game.board[5][p_cor]==0){
				Piece* temp=game.board[y_cor][x_cor];
				Piece* temp2=game.board[4][p_cor];
				game.board[5][p_cor]=game.board[y_cor][x_cor];
				game.board[4][p_cor]=0;
			}
		}
		else if (x_move==p_cor && y_move==(2) && game.board[y_cor][x_cor]->!isBlack){
			if (game.board[2][p_cor]==0){
				Piece* temp=game.board[y_cor][x_cor];
				Piece* temp2=game.board[3][p_cor];
				game.board[2][p_cor]=game.board[y_cor][x_cor];
				game.board[3][p_cor]=0;
			}
		}
	}
}
//after moving (add only to move function)
if (game.board[y_cor][x_cor]->type.compare("pawn")==0){
	if (y_cor+2==y_move){
		en_passant_possible=true;
		p_cor=x_cor;
	}
	else{
		en_passant_possible=false;
	}
}
else{
	en_passant_possible=false;
}

//add to pawn generate move (will always put at the top of the stack if it is a possible move)
//white
if (en_passant_possible){
	if(y_cor==3){
		if (x_cor==p_cor+1 || x_cor==p_cor-1;){
			if (game.board[2][p_cor]==0){
				x_cans.push(p_cor);
				y_cans.push(2);
			}
		}
	}
}
//black
if (en_passant_possible){
	if(y_cor==4){
		if (x_cor==p_cor+1 || x_cor==p_cor-1;){
			if (game.board[5][p_cor]==0){
				x_cans.push(p_cor);
				y_cans.push(5);
			}
		}
	}
}

//Castling only need to add to move since you cannot castle in check
//need to create 6 booleans, can possibly be global
bool can_castle_far=false;
bool can_castle_close=false;
if (game.board[y_cor][x_cor]->type.compare("rook")==0 || game.board[y_cor][x_cor]->type.compare("king")==0){
	if (kb_not){
		if (yourcolor==true) {
			if (cb_far_not){
				if (game.board[0][1]==0 && game.board[0][2]==0 && game.board[0][3]==0)
					can_castle_far=castle_check_far(game,yourcolor);
				}
			}
			if (cb_close_not){
				if (game.board[0][5]==0 && game.board[0][6]==0){
					can_castle_close=castle_check_close(game,yourcolor);
				}
			}
		}
	}
	if (kw_not){
		if (your_color==false){
			if (cw_far_not){
				if (game.board[7][1]==0 && game.board[7][2]==0 && game.board[7][3]==0)
					can_castle_far=castle_check_far(game,yourcolor);
				}
			}
			if (cw_close_not){
				if (game.board[7][5]==0 && game.board[7][6]==0){
					can_castle_close=castle_check_close(game,yourcolor);
				}
			}
		}
	}
	string far="";
	string close=" \n";
	if (can_castle_close){
		close=" close \n";
		if (can_castle_far){
			close="and close \n ";
		}
	}
	if (can_castle_far){
		close="far ";
	}
	if (can_castle_close || can_castle_far){
		cout<<"You can castle "<<far<<close;
		cout<<"would you like to castle? \n 1: Yes \n (Anything else): No \n"
		string input="";
		cin>>input;
		if (input.compare(1)==0){
			cout<<"would you like to castle far or close? \n 1: Far \n (Anything else): Close \n"
			cin>>input;
			if (input.compare(1)==0 && can_castle_far){
				if (your_color){
					game.board[0][3]==game.board[0][0]; 
					game.board[0][2]==game.board[0][4];
				}
				else {
					game.board[7][3]==game.board[7][0]; 
					game.board[7][2]==game.board[7][4];
				}
			}
			else if (can_castle_close){
				if (your_color){
					game.board[0][5]==game.board[0][7]; 
					game.board[0][6]==game.board[0][4];
				}
				else {
					game.board[7][5]==game.board[7][7]; 
					game.board[7][6]==game.board[7][4];
				}
			}
		}
	}
}

//After a move function completes
if (game.board[0][0]->type.compare("rook")!=0){
	cb_far_not=false;
}
if (game.board[0][7]->type.compare("rook")!=0){
	cb_close_not=false;
}
if (game.board[7][0]->type.compare("rook")!=0){
	cw_far_not=false;
}
if (game.board[7][7]->type.compare("rook")!=0){
	cw_close_not=false;
}
if (game.board[0][3]->type.compare("king")!=0){
	kb_not=false;
}
if (game.board[7][3]->type.compare("king")!=0){
	kw_not=false;
}

//New functions
bool castle_check_far(Board game, bool player_isBlack){
	bool can_castle==true;
	if (player_isBlack==true){
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==3 && can_ys.top()==0)||(can_xs.top()==2 && can_ys.top()==0)||(can_xs.top()==4 && can_ys.top()==0){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	else{
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==3 && can_ys.top()==7)||(can_xs.top()==2 && can_ys.top()==7)||(can_xs.top()==4 && can_ys.top()==7){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	return can_castle;
}

bool castle_check_far(Board game, bool player_isBlack){
	can_castle==true;
	if (player_isBlack==true){
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==5 && can_ys.top()==0)||(can_xs.top()==6 && can_ys.top()==0)||(can_xs.top()==4 && can_ys.top()==0){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	else{
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==5 && can_ys.top()==7)||(can_xs.top()==6 && can_ys.top()==7)||(can_xs.top()==4 && can_ys.top()==7){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	return can_castle;
}
