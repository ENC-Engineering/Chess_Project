#include <iostream>
#include <string>
#include "chess_board.h"
#include "chess_pieces.h"

//Check function
//Going to change move to two separate functions, one that generates a move set, the other to move to a place in the subset
//Also will make a function specifically for checkmate called checkmoves

bool check(Board &Game1, bool player_isBlack){
    //Find the person's king of the same color
    bool in_check=false;
    int king_x=0;
    int king_y=0;
    for(int i=0; i<8; i++){
        for(int j = 0; j < 8; j++){
            if (Game1.board[i][j]!=0){
                string piece_type=Game1.board[i][j]->type
                if (piece_type.compare("king")==0){
                    if (Game1.board[i][j]->isBlack==player_isBlack){
                        king_x=j;
                        king_y=i;
                    }
                }
            }
        }
    }
    //Now will check if any moves of the opposite colors pieces will reach the king's coordinates
    for(int i=0; i<8; i++){
        for(int j = 0; j < 8; j++){
            if (Game1.board[i][j]!=0){
                if (Game1.board[i][j]->isBlack != player_isBlack){
                    //Means it found a piece of opposite color of the king in question
                    stack<int> can_xs;
                    stack<int> can_ys;
                    //Generate move is a void method that fills the two stacks with all moves of that piece in Game1 at (j,i)
                    Game1.board[i][j]->generate_moves(j, i, Game1, can_xs, can_ys);
                    while (!can_xs.empty() && !can_ys.empty()){
                        if (can_xs.top()==king_x && can_ys.top()==king_y){
                            in_check=true;
                            break;
                        }
                        can_xs.pop();
                        can_ys.pop();
                    }
                }
            }
            //Exits if it finds that the king is in check
            if (in_check){
                break;
            }
        }
        if (in_check){
            break;
        }
    }
    return in_check;
}

//Going to create a checkmoves function which is like move but automatically moves to all possible places and checks for check
//Outline of checkmate when checkmoves and check is running completely

bool checkmate(Board &Game1, bool player_isBlack){
    //assumes checkmate until proven wrong
    bool in_checkmate=true;
    for(int i=0; i<8; i++){
        for(int j = 0; j < 8; j++){
            if (Game1.board[i][j]!=0){
                if (Game1.board[i][j]->isBlack==player_isBlack){
                    //Checks to see if this piece can block the check, assumes it can't
                    bool can_block=false;
                    can_block=Game1.board[i][j]->checkmoves(j, i, Game1, player_isBlack);
                    if (can_block){
                        in_checkmate=false;    
                    }
                }
            }
            if (!in_checkmate){
                break;
            }
        }
        if (!in_checkmate){
            break;
        }
    }
    return in_checkmate
}

//checkmoves without generate moves
bool checkmoves(int x_pos, int y_pos, Board &Game1, bool player_isBlack){
    //Starts by generating all the moves the piece can do
    bool can_block=false;
    stack<int> can_xs;
    stack<int> can_ys;
    Game1.board[i][j]->generate_moves(j, i, Game1, can_xs, can_ys);
    //Then temporarily moves the piece to all the possible places and see if it can stop the check
    while (!can_xs.empty() && !can_ys.empty()){
        //temporarily moves the piece to see if it would stop check
        int x_move=can_xs.top();
        int y_move=can_ys.top();
        Piece* temp1=Game1.board[i][j];
        Piece* temp2=Game1.board[y_move][x_move];
        Game1.board[y_move][x_move]=Game1.board[i][j];
        Game1.board[i][j]=0;
        bool in_check=check(Game1 , player_isBlack)
        Game1.board[y_move][x_move]=temp2;
        Game1.board[i][j]=temp1;
        if (!in_check){
            can_block=false;
            break;
        }
        can_xs.pop();
        can_ys.pop();
    }
    return can_block
}

//Better move function
bool move(int j, int i, Board &Game1){
    //generates all moves for the piece you are moving
    bool your_color=Game1.board[i][j]->isBlack;
    bool has_moved=false;
    stack<int> can_xs;
    stack<int> can_ys;
    Game1.board[i][j]->generate_moves(j, i, Game1, can_xs, can_ys);
    //inputs where you would like to move
    int x_move=0;
    int y_move=0;
    cout<<"Please enter the (x y) you would like to move to";
    cin>>x_move;
    cin>>y_move;
    //checks to see if the move is on the generated move list
    while (!can_xs.empty() && !can_ys.empty()){
        if (x_move==can_xs.top() && if y_move==can_ys.top()){
            Piece* temp1=Game1.board[i][j];
            Piece* temp2=Game1.board[y_move][x_move];
            Game1.board[y_move][x_move]=Game1.board[i][j];
            Game1.board[i][j]=0;
            //Makes sure the move doesn't put you in check or else it moves you back
            bool put_yourself_incheck=check(Game1, your_color);
            if (put_yourself_incheck){
                cout<<"You can't move there, it puts you in check";
                Game1.board[y_move][x_move]=temp2;
                Game1.board[i][j]=temp1;
                break;
            }
            else {
                has_moved=true;
                break;
            }
        }
        can_xs.pop();
        can_ys.pop();
    }
    return has_moved;
}

//Runs the game
int main() {
    bool isBlack = false;
    Piece pieces[6][2] =
        {{Pawn(!isBlack), Pawn(isBlack)},
        {King(!isBlack), King(isBlack)},
        {Queen(!isBlack), Queen(isBlack)},
        {Bishop(!isBlack), Bishop(isBlack)},
        {Knight(!isBlack), Knight(isBlack)},
        {Rook(!isBlack), Rook(isBlack)}};
    Board Game1(1, pieces);
    for(int i = 0; i < 8; i++){
        for(int j = 0; j < 8; j++){
            cout<< Game1.board[i][j]->type<<"\t";
        }
        cout<< "\n\n";
    }
    //New variable to see whose turn it is
    bool player_isBlack_turn=true;
    Game1.deleteBoard();
    return 0;
}
