#include <iostream>
#include "chess_board.h"
#include "chess_pieces.h"

using namespace std;

//Check function
//Going to change move to two separate functions, one that generates a move set, the other to move to a place in the subset
//Also will make a function specifically for checkmate called checkmoves

bool check(Board game, bool player_isBlack){
    //Find the person's king of the same color
    bool in_check=false;
    int king_x=0;
    int king_y=0;
    for(int y_pos=0; y_pos<8; y_pos++){
        for(int x_pos = 0; x_pos < 8; x_pos++){
            if (game.board[y_pos][x_pos]!=0){
                string piece_type=game.board[y_pos][x_pos]->type;
                if (piece_type.compare("king")==0){
                    if (game.board[y_pos][x_pos]->isBlack==player_isBlack){
                        king_x=x_pos;
                        king_y=y_pos;
                    }
                }
            }
        }
    }
    //Now will check if any moves of the opposite colors pieces will reach the king's coordinates
    for(int y_pos=0; y_pos<8; y_pos++){
        for(int x_pos = 0; x_pos < 8; x_pos++){
            if (game.board[y_pos][x_pos]!=0){
                if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
                    //Means it found a piece of opposite color of the king in question
                    stack<int> can_xs;
                    stack<int> can_ys;
                    //Generate move is a void method that fills the two stacks with all moves of that piece in game at (j,i)
                    game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
                    while (!can_xs.empty() && !can_ys.empty()){
						if (can_xs.top()==king_x && can_ys.top()==king_y){
                            in_check=true;
                            break;
                        }
                        can_xs.pop();
                        can_ys.pop();
                    }
                }
            }
            //Exits if it finds that the king is in check
            if (in_check){
                break;
            }
        }
        if (in_check){
            break;
        }
    }
    return in_check;
}

bool move(Board game, int x_cor, int y_cor, bool blacksTurn) {
    //generates all moves for the piece you are moving
    bool has_moved=false;
    stack<int> x_cans1;
    stack<int> y_cans1;
    stack<int> x_cans2;
    stack<int> y_cans2;
	//generates all moves for the piece
    game.board[y_cor][x_cor]->generate_moves(game, x_cor, y_cor, x_cans1, y_cans1);
    if (x_cans1.empty() || y_cans1.empty()) {
        cout<< "Cannot move \n";
    }
    else {
        while (!x_cans1.empty() && !y_cans1.empty()) {
            cout << "(" << x_cans1.top()+1 << ", " << 8 - y_cans1.top() << ") ; ";
            x_cans2.push(x_cans1.top());
            x_cans1.pop();
            y_cans2.push(y_cans1.top());
            y_cans1.pop();
        }
    }
    cout<< "\n";
    //inputs where you would like to move
    int x_move=0;
    int y_move=0;
	if (!x_cans2.empty() && !y_cans2.empty()){
		cout<<"Please enter the (x, y) you would like to move to \n";
		cin>>x_move;
		cin>>y_move;
	}
    x_move = x_move - 1;
    y_move = 8 - y_move;
    //checks to see if the move is on the generated move list
    while (!x_cans2.empty() && !y_cans2.empty()){
        if (x_move==x_cans2.top() && y_move==y_cans2.top()){
            Piece* temp1=game.board[y_cor][x_cor];
            Piece* temp2=game.board[y_move][x_move];
            game.board[y_move][x_move]=game.board[y_cor][x_cor];
            game.board[y_cor][x_cor]=0;
            //Makes sure the move doesn't put you in check or else it moves you back
            bool put_yourself_incheck = check(game, blacksTurn);
            if (put_yourself_incheck==true){
			   cout<<"You can't move there, it puts you in check";
			   game.board[y_move][x_move]=temp2;
               game.board[y_cor][x_cor]=temp1;
               break;
            }
            else {
                has_moved=true;
                break;
			}
        }
        x_cans2.pop();
        y_cans2.pop();
    }
    return has_moved;
}

//checkmoves without generate moves
bool checkmoves(Board game, int x_pos, int y_pos, bool player_isBlack){
    //Starts by generating all the moves the piece can do
    bool can_block=false;
    stack<int> can_xs;
    stack<int> can_ys;
    game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
    while (!can_xs.empty() && !can_ys.empty()){
        int x_move=can_xs.top();
        int y_move=can_ys.top();
        Piece* temp1=game.board[y_pos][x_pos];
        Piece* temp2=game.board[y_move][x_move];
        game.board[y_move][x_move]=game.board[y_pos][x_pos];
        game.board[y_pos][x_pos]=0;
        bool in_check = check(game, player_isBlack);
        game.board[y_move][x_move]=temp2;
        game.board[y_pos][x_pos]=temp1;
        if (!in_check){
            can_block=true;
            break;
        }
        can_xs.pop();
        can_ys.pop();
    }
    return can_block;
}

//Method for checkmate
bool checkmate(Board game, bool player_isBlack){
    //assumes checkmate until proven wrong
    bool in_checkmate=true;
    for(int y_pos=0; y_pos<8; y_pos++){
        for(int x_pos = 0; x_pos < 8; x_pos++){
            if (game.board[y_pos][x_pos]!=0){
                if (game.board[y_pos][x_pos]->isBlack==player_isBlack){
                    //Checks to see if this piece can block the check, assumes it can't
                    bool can_block=false;
                    can_block = checkmoves(game, x_pos, y_pos, player_isBlack);
                    if (can_block==true){
                        in_checkmate=false;
                    }
                }
            }
            if (in_checkmate==false){
                break;
            }
        }
        if (in_checkmate==false){
            break;
        }
    }
    return in_checkmate;
}

//New functions that check for castling on the left side of kings
bool castle_check_far(Board game, bool player_isBlack){
	bool can_castle=true;
	if (player_isBlack==true){
		//has a special check for pawns of opposite color at any of the spaces
		for(int i=1; i<5; i++){
			if (game.board[6][i]!=0){
				if (game.board[6][i]->type.compare("pawn")==0 && game.board[1][i]->isBlack==false){
					can_castle=false;
				}
			}
		}
		//checks for all other pieces
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==3 && can_ys.top()==0)||(can_xs.top()==2 && can_ys.top()==0)||(can_xs.top()==4 && can_ys.top()==0)){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	else{
		//has a special check for pawns of opposite color at any of the spaces
		for(int i=1; i<5; i++){
			if (game.board[1][i]!=0){
				if (game.board[1][i]->type.compare("pawn")==0 && game.board[1][i]->isBlack){
					can_castle=false;
				}
			}
		}
		//check for all other pieces
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==3 && can_ys.top()==7)||(can_xs.top()==2 && can_ys.top()==7)||(can_xs.top()==4 && can_ys.top()==7)){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	return can_castle;
}

//checks for castling on the right side of kings
bool castle_check_close(Board game, bool player_isBlack){
	bool can_castle=true;
	if (player_isBlack==true){
		//has a special check for pawns of opposite color at any of the spaces
		for(int i=4; i<8; i++){
			if (game.board[6][i]!=0){
				if (game.board[6][i]->type.compare("pawn")==0 && game.board[1][i]->isBlack==false){
					can_castle=false;
				}
			}
		}
		//checks for all other pieces
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==5 && can_ys.top()==0)||(can_xs.top()==6 && can_ys.top()==0)||(can_xs.top()==4 && can_ys.top()==0)){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	else{
		//has a special check for pawns of opposite color at any of the spaces
		for(int i=4; i<8; i++){
			if (game.board[1][i]!=0){
				if (game.board[1][i]->type.compare("pawn")==0 && game.board[1][i]->isBlack){
					can_castle=false;
				}
			}
		}
		//checks for all other pieces
		for(int y_pos=0; y_pos<8; y_pos++){
			for(int x_pos = 0; x_pos < 8; x_pos++){
				if (game.board[y_pos][x_pos]!=0){
					if (game.board[y_pos][x_pos]->isBlack != player_isBlack){
						stack<int> can_xs;
						stack<int> can_ys;
						game.board[y_pos][x_pos]->generate_moves(game, x_pos, y_pos, can_xs, can_ys);
						while (!can_xs.empty() && !can_ys.empty()){
							if ((can_xs.top()==5 && can_ys.top()==7)||(can_xs.top()==6 && can_ys.top()==7)||(can_xs.top()==4 && can_ys.top()==7)){
								can_castle=false;
								break;
							}
							can_xs.pop();
							can_ys.pop();
						}
					}
				}
				if (can_castle==false){
					break;
				}
			}
			if (can_castle==false){
				break;
			}
		}
	}
	return can_castle;
}


//The actual game
int main() {
    bool isBlack = false;
    Piece* pieces[6][2] =
        {
        {new Pawn(!isBlack),    new Pawn(isBlack)},
        {new King(!isBlack),    new King(isBlack)},
        {new Queen(!isBlack),   new Queen(isBlack)},
        {new Bishop(!isBlack),  new Bishop(isBlack)},
        {new Knight(!isBlack),  new Knight(isBlack)},
        {new Rook(!isBlack),    new Rook(isBlack)}
        };
    Board Game1(1, pieces);
    Game1.printBoard();
    bool quit = false;
    bool blacksTurn = false;
	//Sets up that none of the rooks or kings have moved and no en_passant
	bool cb_far_not=true;
	bool cb_close_not=true;
	bool cw_far_not=true;
	bool cw_close_not=true;
	bool kb_not=true;
	bool kw_not=true;
	bool en_passant=false;
	int p_cor=0;
	//runs the game until you choose to quit or checkmate occurs
    while (!quit) {
        bool hasMoved = false;
        if (blacksTurn) {
            cout << "Black's turn, press enter to continue.\n";
        }
        else {
            cout << "White's turn, press enter to continue.\n";
        }
        cin.ignore();
        cout<< "Choose an option:\n\t1 = Move\n\t2 = Quit\n";
        string choice;
        cin >> choice;
        if (choice.compare("2")==0) {
            break;
        }
        while (!hasMoved) {
            int x_cor;
            int y_cor;
            cout<< "Where is the piece that you want to move (x,y)?\n";
            cin>> x_cor;
            cin>> y_cor;
            if (x_cor<1 || x_cor>8 || y_cor<1 || y_cor>8) {
                cout<< "Error: Invalid Space, try again.\n";
                continue;
            }
            x_cor = x_cor - 1;
            y_cor = 8 - y_cor;
            if (Game1.board[y_cor][x_cor]!=0){
                if (Game1.board[y_cor][x_cor]->isBlack==blacksTurn) {
                    cout<< "\nYou selected a " << Game1.board[y_cor][x_cor]->type<<"\n";
					//Runs to see if you can castle
					bool can_castle_far=false;
					bool can_castle_close=false;
					if (Game1.board[y_cor][x_cor]->type.compare("rook")==0 || Game1.board[y_cor][x_cor]->type.compare("king")==0){
						if (kb_not){
							if (blacksTurn==true) {
								if (cb_far_not){
									if (Game1.board[0][1]==0 && Game1.board[0][2]==0 && Game1.board[0][3]==0){
										can_castle_far=castle_check_far(Game1,blacksTurn);
									}
								}
								if (cb_close_not){
									if (Game1.board[0][5]==0 && Game1.board[0][6]==0){
										can_castle_close=castle_check_close(Game1,blacksTurn);
									}
								}
							}
						}
						if (kw_not){
							if (blacksTurn==false){
								if (cw_far_not){
									if (Game1.board[7][1]==0 && Game1.board[7][2]==0 && Game1.board[7][3]==0){
										can_castle_far=castle_check_far(Game1,blacksTurn);
									}
								}
								if (cw_close_not){
									if (Game1.board[7][5]==0 && Game1.board[7][6]==0){
										can_castle_close=castle_check_close(Game1,blacksTurn);
									}
								}
							}
						}
						if (can_castle_close || can_castle_far){
							cout<<"You can castle \n";
							string input="";
							if (input.compare("1")!=0 ||input.compare("1")!=0 ){
								if (can_castle_far){
									cout<<"Would you like to castle far? \n 1: Yes \n (Anything Else): No";
									cin>>input;
								}
								if (input.compare("1")==0 && can_castle_far){
									if (blacksTurn==true){
										Game1.board[0][3]=Game1.board[0][0]; 
										Game1.board[0][2]=Game1.board[0][4];
										Game1.board[0][0]=0;
										Game1.board[0][4]=0;
										en_passant=false;
										break;
									}
									else {
										Game1.board[7][3]=Game1.board[7][0]; 
										Game1.board[7][2]=Game1.board[7][4];
										Game1.board[7][0]=0;
										Game1.board[7][4]=0;
										en_passant=false;
										break;
									}
								}
								if (can_castle_close){
									cout<<"Would you like to castle close? \n 1: Yes \n (Anything Else): No";
									cin>>input;
								}
								else if (input.compare("1")==0 && can_castle_close){
									if (blacksTurn==true){
										Game1.board[0][5]=Game1.board[0][7]; 
										Game1.board[0][6]=Game1.board[0][4];
										Game1.board[0][7]=0;
										Game1.board[0][4]=0;
										en_passant=false;
										break;
									}
									else {
										Game1.board[7][5]=Game1.board[7][7]; 
										Game1.board[7][6]=Game1.board[7][4];
										Game1.board[7][7]=0;
										Game1.board[7][4]=0;
										en_passant=false;
										break;
									}
								}
							}
						}
					}
					//is the actual move command so long as you choose not to castle
                    hasMoved = move(Game1, x_cor, y_cor, blacksTurn, en_passant, p_cor);
                }
                else {
                    cout<< "Not your piece, try again!\n";
                    continue;
                }
            }
			else {
				cout<<"No piece there \n";
			}
        }
		
		//Runs all this after you move
		//Checks to see if any of the rooks or kings have moved
		if (Game1.board[0][0]!=0){
			if (Game1.board[0][0]->type.compare("rook")!=0 || Game1.board[0][0]->isBlack==false){
				cb_far_not=false;
			}
		}
		else{
			cb_far_not=false;
		}
		if (Game1.board[0][7]!=0){
			if (Game1.board[0][7]->type.compare("rook")!=0 || Game1.board[0][7]->isBlack==false){
				cb_close_not=false;
			}
		}
		else{
			cb_close_not=false;
		}
		if (Game1.board[7][0]!=0){
			if (Game1.board[7][0]->type.compare("rook")!=0 || Game1.board[7][0]->isBlack==true){
				cw_far_not=false;
			}
		}
		else{
			cw_far_not=false;
		}
		if (Game1.board[7][7]!=0){
			if (Game1.board[7][7]->type.compare("rook")!=0 || Game1.board[7][7]->isBlack==true){
				cw_close_not=false;
			}
		}
		else{
			cw_close_not=false;
		}
		if (Game1.board[0][4]!=0){
			if (Game1.board[0][4]->type.compare("king")!=0|| Game1.board[0][4]->isBlack==false){
				kb_not=false;
			}
		}
		else{
			kb_not=false;
		}
		if (Game1.board[7][4]!=0){
			if (Game1.board[7][4]->type.compare("king")!=0|| Game1.board[7][4]->isBlack==true){
				kw_not=false;
			}
		}
		else{
			kw_not=false;
		}
		//Pawn promotion automatically makes a pawn a queen
		for (int i=0;i<8;i++){
			if (Game1.board[7][i]!=0){
				if (Game1.board[7][i]->type.compare("pawn")==0){
					Game1.board[7][i]=pieces[2][0];
					cout<<"\nPawn Promotion!\n";
				}
			}
			if (Game1.board[0][i]!=0){
				if (Game1.board[0][i]->type.compare("pawn")==0){
					Game1.board[0][i]=pieces[2][1];
					cout<<"\nPawn Promotion!\n";
				}
			}
		}
		//runs to see if you pute your oppenent in check
		bool in_check=check(Game1, !blacksTurn);
		if (in_check){
			cout<<"King is in check \n";
			bool in_check_mate=checkmate(Game1, !blacksTurn, en_passant, p_cor);
			if (in_check_mate){
				quit=true;
				cout<<"Check-mate game is over! \n";
			}
		}
        blacksTurn = !blacksTurn;
        Game1.printBoard();
    }
    Game1.deleteBoard();
    return 0;
}
